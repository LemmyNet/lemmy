use itertools::Itertools;
use std::{
  collections::BTreeSet,
  ffi::OsStr,
  fmt::Write,
  fs::{read_dir, read_to_string, write},
  path::Path,
};

fn main() -> std::io::Result<()> {
  let mut result = "// @generated by scripts/lint.sh\nuse crate::schema::*;use diesel::allow_tables_to_appear_in_same_query as a;".to_owned();
  let mut files = vec![];
  let mut remaining_dir_paths = vec![Path::new("crates").to_owned(), Path::new("src").to_owned()];
  while let Some(dir_path) = remaining_dir_paths.pop() {
    for dir_entry in read_dir(&dir_path)? {
      let dir_entry = dir_entry?;
      if dir_entry.file_type()?.is_dir() {
        remaining_dir_paths.push(dir_entry.path());
      } else if dir_entry.path().extension().map(OsStr::as_encoded_bytes) == Some(b"rs") {
        files.push(read_to_string(dir_entry.path())?);
      }
    }
  }
  let pairs = files
    .iter()
    .flat_map(|s| s.split("fn "))
    .flat_map(|fn_chunk| {
      fn_chunk
        .split("::")
        .tuple_windows()
        .filter(|(before, after)| {
          if let Some(s) = after.strip_prefix("table") {
            !s.starts_with('!')
          } else {
            before.ends_with("_actions")
          }
        })
        .filter_map(|(before, after)| {
          before.rsplit_once(|c: char| !(c.is_ascii_alphabetic() || c == '_'))
        })
        .map(|s| s.1)
        .filter(|&s| s.chars().all(|c| !c.is_ascii_uppercase()) && s != "pg_namespace")
        .combinations(2)
        .filter_map(|v| <[&str; 2]>::try_from(v).ok())
        .filter(|[a, b]| a != b && !a.is_empty() && !b.is_empty())
        .map(|mut arr| {
          arr.sort_unstable();
          arr
        })
    })
    .collect::<BTreeSet<_>>();
  for [a, b] in pairs {
    write!(&mut result, "a!({a}, {b});").expect("");
  }
  lazy_write("crates/db_schema/src/table_pairs.rs", &result)?;
  Ok(())
}

fn lazy_write(path: &str, new: &str) -> std::io::Result<()> {
  let old = read_to_string(path)?;
  if old != new {
    write(path, new)?;
  }
  Ok(())
}
